# Guide: Operationalize automated deployments

## Success Criteria

* The ARM deployments should be executed in _complete_ mode (versus _incremental_ mode) so that resources not specified in the ARM template will be destroyed.
* The attendees will need to build _at least_ three separate build and release pipelines&mdash;a separate build and release pipeline for each project. They will need to demonstrate that each build and release pipeline is functional.
* All three release pipelines should have an approval gate that requires human approval prior to a build being published to production. Attendees must demonstrate the operating approval gate.
* The team must configure a _pre-deployment_ step in the release pipeline that, using a `what-if` flag, reports the potential changes to the environment prior to them being implemented. Only if the fictitious Woodgrove Bank IT team confirms the changes in the pre-deployment step will they approve the push to production.
* Parameters in the Azure Bicep scripts must be annotated with `@allowed` and the arrays must contain a set of "allowable" SKUs. It isn't important _which_ SKUs the team chooses. The requirement is that the team demonstrates _how_ to accomplish this.
* Attendees must explore various deployment strategies so that the application remains completely operational while being deployed. The team isn't required to configure the strategy in this challenge. They should, however, be aware of the various strategies and discuss the benefits and drawbacks of each.
* A separate development environment should be deployed.
* The team should be prepared to present their chosen deployment strategy and explain why they chose that strategy compared to others.

## Hints/Suggestions

* Unless someone of the team has had previous experience with Azure Bicep, it may prove to be the most difficult aspect of this challenge. It may be helpful if the team pauses to explore the capabilities and usage of Azure Bicep.
* This challenge should engage both developers and infrastructure architects as it requires a mixture of DevOps and ARM. If the team appears overwhelmed, encourage the team to split up and prioritize the requirements so that they can work in parallel.

## References

* <a href="https://docs.microsoft.com/azure/azure-resource-manager/templates/deployment-modes" target="_blank">ARM deployment modes</a>
* <a href="https://docs.microsoft.com/azure/azure-resource-manager/templates/bicep-tutorial-add-parameters?tabs=azure-powershell#customize-by-environment" target="_blank">Using `@allowed` in Azure Bicep parameters</a>

## Technical Guidance

> **IMPORTANT:** Currently, the Azure Bicep scripts will redeploy a _saved_ version of the applications to the virtual machines via Desired State Configuration (DSC). However, when the VMs are redeployed, the team will need to "reconnect" them to their Azure DevOps tenant in order to deploy application builds from Azure DevOps to the machines. The process is detailed below.

### Infrastructure Builds

1. For the deploying the infrastructure into the Azure tenant, a _Service Connection_ will need to be established for the project in Azure DevOps.
2. Under the _Bicep_ project and when view the file repository, you will find the aforementioned `azure-pipelines.yml`. This script, when used for a Build Pipeline, will produce two files:

   1. `deploymentParameters.json` - a set a parameters required to deploy the generated ARM template
   2. `main.json` - the ARM template generated by Azure Bicep

   These files will be placed in a `drop` folder to be used by a Release Pipeline that the team will need to configure.
3. When creating a _Build Pipeline_, choose the _Azure Repos Git_ as a source, and Azure DevOps will automatically find the `azure-pipelines.yml` file.
4. The _Release Pipeline_ should have **4** stages&mdash;one for development, one for production, and one each for verification of both environments _prior_ to the release. Each verification stage should come before each release stage (e.g., Dev - Verify -> Dev -> Prod - Verify -> Prod).
5. The verification stages stages should include a `-Whatif` parameter in the release so that Woodgrove Bank's IT administrators can see the changes that will be made to each environment _prior to_ the changes actually being made.
6. Each stage in the release pipeline should be _manual_.
7. The release to the production environment should be _gated_ and require an administrator's (another user on the team) approval.
8. It is not required, but encouraged that teams practice using _Variable Groups_ in order to make reuse of variables easier and more secure. Additionally, this will help in later challenges when the use of Key Vault within pipelines is required.
9. Teams can use the _ARM Template Deployment_ task in their release pipelines, or they are free to use the Azure CLI in a bash/powershell script. Their choice and some individuals, based on their experience, may favor one over the other.
10. As the note states above, you will need to add each virtual machine to an Azure DevOps deployment group.
11. As part of the _Success Criteria_ this is one small change that the team will need to make to the Bicep definitions. The _Success Criteria_ states that the team need to provide the correct labels to each environment so that the IT and Accounting teams can determine which environments are production and which are development. Additionally, in Challenge 1, the team added the _Department_ tag, this will also need to be added to the Bicep definitions. While the team could tag _each_ resource, <a href="https://docs.microsoft.com/azure/templates/microsoft.resources/tags?tabs=bicep" target="_top">tagging the resource group</a> is sufficient for this exercise. (The will need to add a `Microsoft.Resources/tags` resource to their Bicep definition.)

### Application Builds

1. There are two repositories in the _Portal_ project (the _web_ repo contains the front-end and backend of the web application). The team will need to construct build and release pipelines for both.
2. Each repo contains an `azure-pipelines.yml` build script that fully builds the application and places the correct artifacts in its respective `drop` folder. Like the infrastructure builds, the team does not have to rewrite the build scripts (no changes are needed). Instead, it is highly encouraged that the teams simply use what is there to construct the build pipelines.
3. As the previous point states, all artifacts for the builds are placed in `drop` folders. The release pipelines will need to pull the artifacts from these folders.
4. As the note above states, the team will need to install the Azure DevOps deployment agent on each VM prior to attempting a deployment. This is a PowerShell script that is provided to you by Azure DevOps. The team will simply need to add a new deployment group (found under _Pipelines_ in Azure DevOps).
5. **IMPORTANT:** When configuring the deployment task for each application, the team needs to make sure that they are deploying the application components to the _correct folders_ on the VMs. They should not assume that the application is deployed to any default web folder or such. It would be helpful if the team has RDP'ed into the VM to assess where the application components (e.g., front-end, backend, processor) for each application are deployed.
6. Remember, the application components should have stages for deployment to the development and production environments with the deployment to production being _gated_.
